{
  "resolvedId": "/Users/lois/Documents/GitHub/blog-lois-solid/node_modules/.pnpm/solid-start@0.2.26_@solidjs+meta@0.28.2_@solidjs+router@0.8.2_solid-js@1.7.2_solid-start-node@0.2.19_vite@4.1.4/node_modules/solid-start/api/router.ts",
  "transforms": [
    {
      "name": "__load__",
      "result": "import { MatchRoute, Method } from \"./types\";\n\nexport function getRouteMatches(routes: MatchRoute[], path: string, method: Method) {\n  const segments = path.split(\"/\").filter(Boolean);\n\n  routeLoop: for (const route of routes) {\n    const matchSegments = route.matchSegments;\n\n    if (\n      segments.length < matchSegments.length ||\n      (!route.wildcard && segments.length > matchSegments.length)\n    ) {\n      continue;\n    }\n\n    for (let index = 0; index < matchSegments.length; index++) {\n      const match = matchSegments[index];\n      if (!match) {\n        continue;\n      }\n\n      if (segments[index] !== match) {\n        continue routeLoop;\n      }\n    }\n\n    const handler = route[method];\n    if (handler === \"skip\" || handler === undefined) {\n      return;\n    }\n\n    const params: Record<string, string> = {};\n    for (const { type, name, index } of route.params) {\n      if (type === \":\") {\n        params[name] = segments[index];\n      } else {\n        params[name] = segments.slice(index).join(\"/\");\n      }\n    }\n\n    return { handler, params };\n  }\n}\n",
      "start": 1686078493309,
      "end": 1686078493309
    },
    {
      "name": "vite:esbuild",
      "result": "export function getRouteMatches(routes, path, method) {\n  const segments = path.split(\"/\").filter(Boolean);\n  routeLoop:\n    for (const route of routes) {\n      const matchSegments = route.matchSegments;\n      if (segments.length < matchSegments.length || !route.wildcard && segments.length > matchSegments.length) {\n        continue;\n      }\n      for (let index = 0; index < matchSegments.length; index++) {\n        const match = matchSegments[index];\n        if (!match) {\n          continue;\n        }\n        if (segments[index] !== match) {\n          continue routeLoop;\n        }\n      }\n      const handler = route[method];\n      if (handler === \"skip\" || handler === void 0) {\n        return;\n      }\n      const params = {};\n      for (const { type, name, index } of route.params) {\n        if (type === \":\") {\n          params[name] = segments[index];\n        } else {\n          params[name] = segments.slice(index).join(\"/\");\n        }\n      }\n      return { handler, params };\n    }\n}\n",
      "start": 1686078493309,
      "end": 1686078493313,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "result": "export function getRouteMatches(routes, path, method) {\n  const segments = path.split(\"/\").filter(Boolean);\n  routeLoop:\n    for (const route of routes) {\n      const matchSegments = route.matchSegments;\n      if (segments.length < matchSegments.length || !route.wildcard && segments.length > matchSegments.length) {\n        continue;\n      }\n      for (let index = 0; index < matchSegments.length; index++) {\n        const match = matchSegments[index];\n        if (!match) {\n          continue;\n        }\n        if (segments[index] !== match) {\n          continue routeLoop;\n        }\n      }\n      const handler = route[method];\n      if (handler === \"skip\" || handler === void 0) {\n        return;\n      }\n      const params = {};\n      for (const { type, name, index } of route.params) {\n        if (type === \":\") {\n          params[name] = segments[index];\n        } else {\n          params[name] = segments.slice(index).join(\"/\");\n        }\n      }\n      return { handler, params };\n    }\n}\n",
      "start": 1686078493313,
      "end": 1686078493313,
      "order": "normal"
    },
    {
      "name": "vite:import-analysis",
      "result": "export function getRouteMatches(routes, path, method) {\n  const segments = path.split(\"/\").filter(Boolean);\n  routeLoop:\n    for (const route of routes) {\n      const matchSegments = route.matchSegments;\n      if (segments.length < matchSegments.length || !route.wildcard && segments.length > matchSegments.length) {\n        continue;\n      }\n      for (let index = 0; index < matchSegments.length; index++) {\n        const match = matchSegments[index];\n        if (!match) {\n          continue;\n        }\n        if (segments[index] !== match) {\n          continue routeLoop;\n        }\n      }\n      const handler = route[method];\n      if (handler === \"skip\" || handler === void 0) {\n        return;\n      }\n      const params = {};\n      for (const { type, name, index } of route.params) {\n        if (type === \":\") {\n          params[name] = segments[index];\n        } else {\n          params[name] = segments.slice(index).join(\"/\");\n        }\n      }\n      return { handler, params };\n    }\n}\n",
      "start": 1686078493313,
      "end": 1686078493313,
      "order": "normal"
    }
  ]
}
