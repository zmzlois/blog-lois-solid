{
  "resolvedId": "/@solid-refresh",
  "transforms": [
    {
      "name": "solid",
      "result": "import { $DEVCOMP, createMemo, untrack, createSignal, DEV } from 'solid-js';\n\nfunction setComponentProperty(component, key, value) {\n    const descriptor = Object.getOwnPropertyDescriptor(component, key);\n    if (descriptor) {\n        Object.defineProperty(component, key, Object.assign(Object.assign({}, descriptor), { value }));\n    }\n    else {\n        Object.defineProperty(component, key, {\n            value,\n            writable: false,\n            enumerable: false,\n            configurable: true\n        });\n    }\n}\nfunction createProxy(source, name, location) {\n    const refreshName = `[solid-refresh]${name}`;\n    function HMRComp(props) {\n        const s = source();\n        if (!s || $DEVCOMP in s) {\n            return createMemo(() => {\n                const c = source();\n                if (c) {\n                    return untrack(() => c(props));\n                }\n                return undefined;\n            }, {\n                name: refreshName\n            });\n        }\n        // no $DEVCOMP means it did not go through devComponent so source() is a regular function, not a component\n        return s(props);\n    }\n    setComponentProperty(HMRComp, 'name', refreshName);\n    if (location) {\n        setComponentProperty(HMRComp, 'location', location);\n    }\n    return new Proxy(HMRComp, {\n        get(_, property) {\n            return source()[property];\n        },\n        set(_, property, value) {\n            source()[property] = value;\n            return true;\n        }\n    });\n}\n\nfunction isListUpdated(a, b) {\n    if (a == null && b != null) {\n        return true;\n    }\n    if (a != null && b == null) {\n        return true;\n    }\n    if (a && b) {\n        const aKeys = Object.keys(a);\n        const bKeys = Object.keys(b);\n        // Check if both objects has the same amount of keys\n        if (aKeys.length !== bKeys.length) {\n            return true;\n        }\n        // Merge keys\n        const keys = new Set([...aKeys, ...bKeys]);\n        // Now check if merged keys has the same amount of keys as the other two\n        // for example: { a, b } and { a, c } produces { a, b, c }\n        if (keys.size !== aKeys.length) {\n            return true;\n        }\n        // Now compare each items\n        for (const key of keys.keys()) {\n            if (!Object.is(a[key], b[key])) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nfunction $$registry() {\n    return {\n        components: new Map(),\n        contexts: new Map()\n    };\n}\nfunction $$component(registry, id, component, options = {}) {\n    const [comp, setComp] = createSignal(component, { internal: true });\n    const proxy = createProxy(comp, id, options.location);\n    registry.components.set(id, Object.assign({ id,\n        component,\n        proxy, update: setComp }, options));\n    return proxy;\n}\nfunction $$context(registry, id, context) {\n    registry.contexts.set(id, {\n        id,\n        context\n    });\n    return context;\n}\nfunction patchComponent(oldData, newData) {\n    // Check if incoming module has signature\n    if (newData.signature) {\n        // Compare signatures\n        if (newData.signature !== oldData.signature ||\n            isListUpdated(newData.dependencies, oldData.dependencies)) {\n            // Replace signatures and dependencies\n            oldData.dependencies = newData.dependencies;\n            oldData.signature = newData.signature;\n            // Remount\n            oldData.update(() => newData.component);\n        }\n    }\n    else {\n        // No granular update, remount\n        oldData.update(() => newData.component);\n    }\n    // Always rely on the first proxy\n    // This is to allow modules newly importing\n    // the updated version to still be able\n    // to render the latest version despite\n    // not receiving the first proxy\n    newData.update(() => oldData.proxy);\n}\nfunction patchComponents(oldData, newData) {\n    const components = new Set([...oldData.components.keys(), ...newData.components.keys()]);\n    for (const key of components) {\n        const oldComponent = oldData.components.get(key);\n        const newComponent = newData.components.get(key);\n        if (oldComponent) {\n            if (newComponent) {\n                patchComponent(oldComponent, newComponent);\n            }\n            else {\n                // We need to invalidate\n                return true;\n            }\n        }\n        else if (newComponent) {\n            oldData.components.set(key, newComponent);\n        }\n    }\n    return false;\n}\nfunction patchContext(oldData, newData) {\n    oldData.context.defaultValue = newData.context.defaultValue;\n    newData.context.id = oldData.context.id;\n    newData.context.Provider = oldData.context.Provider;\n}\nfunction patchContexts(oldData, newData) {\n    const contexts = new Set([...oldData.contexts.keys(), ...newData.contexts.keys()]);\n    for (const key of contexts.keys()) {\n        const oldContext = oldData.contexts.get(key);\n        const newContext = newData.contexts.get(key);\n        if (oldContext) {\n            if (newContext) {\n                patchContext(oldContext, newContext);\n            }\n            else {\n                // We need to invalidate\n                return true;\n            }\n        }\n        else if (newContext) {\n            oldData.contexts.set(key, newContext);\n        }\n    }\n    return false;\n}\nfunction patchRegistry(oldRegistry, newRegistry) {\n    const shouldInvalidateByContext = patchContexts(oldRegistry, newRegistry);\n    const shouldInvalidateByComponents = patchComponents(oldRegistry, newRegistry);\n    // In the future we may add other HMR features here\n    return shouldInvalidateByComponents || shouldInvalidateByContext;\n}\nconst SOLID_REFRESH = 'solid-refresh';\nconst SOLID_REFRESH_PREV = 'solid-refresh-prev';\nfunction $$decline(...[type, hot, inline]) {\n    switch (type) {\n        case 'esm':\n            // Snowpack's ESM assumes invalidate as a normal page reload\n            // decline should be better\n            if (inline) {\n                hot.invalidate();\n            }\n            else {\n                hot.decline();\n            }\n            break;\n        case 'vite':\n            // Vite is no-op on decline, just call invalidate\n            if (inline) {\n                hot.invalidate();\n            }\n            else {\n                hot.accept(() => {\n                    hot.invalidate();\n                });\n            }\n            break;\n        case 'rspack-esm':\n        case 'webpack5':\n            if (inline) {\n                hot.invalidate();\n            }\n            else {\n                hot.decline();\n            }\n            break;\n        case 'standard':\n            // Some implementations do not have decline/invalidate\n            if (inline) {\n                if (hot.invalidate) {\n                    hot.invalidate();\n                }\n                else {\n                    window.location.reload();\n                }\n            }\n            else if (hot.decline) {\n                hot.decline();\n            }\n            else {\n                hot.accept(() => {\n                    if (hot.invalidate) {\n                        hot.invalidate();\n                    }\n                    else {\n                        window.location.reload();\n                    }\n                });\n            }\n            break;\n    }\n}\nlet warned = false;\nfunction shouldWarnAndDecline() {\n    const result = DEV && Object.keys(DEV).length;\n    if (result) {\n        return false;\n    }\n    if (!warned) {\n        console.warn(\"To use solid-refresh, you need to use the dev build of SolidJS. Make sure your build system supports package.json conditional exports and has the 'development' condition turned on.\");\n        warned = true;\n    }\n    return true;\n}\nfunction $$refreshESM(type, hot, registry) {\n    if (shouldWarnAndDecline()) {\n        $$decline(type, hot);\n    }\n    else if (hot.data) {\n        hot.data[SOLID_REFRESH] = hot.data[SOLID_REFRESH] || registry;\n        hot.data[SOLID_REFRESH_PREV] = registry;\n        hot.accept(mod => {\n            if (mod == null || patchRegistry(hot.data[SOLID_REFRESH], hot.data[SOLID_REFRESH_PREV])) {\n                hot.invalidate();\n            }\n        });\n    }\n    else {\n        // I guess just decline if hot.data doesn't exist\n        $$decline(type, hot);\n    }\n}\nfunction $$refreshStandard(type, hot, registry) {\n    if (shouldWarnAndDecline()) {\n        $$decline(type, hot);\n    }\n    else {\n        const current = hot.data;\n        if (current && current[SOLID_REFRESH]) {\n            if (patchRegistry(current[SOLID_REFRESH], registry)) {\n                $$decline(type, hot, true);\n            }\n        }\n        hot.dispose((data) => {\n            data[SOLID_REFRESH] = current ? current[SOLID_REFRESH] : registry;\n        });\n        hot.accept();\n    }\n}\nfunction $$refresh(...[type, hot, registry]) {\n    switch (type) {\n        case 'esm':\n        case 'vite':\n            $$refreshESM(type, hot, registry);\n            break;\n        case 'standard':\n        case 'webpack5':\n        case 'rspack-esm':\n            $$refreshStandard(type, hot, registry);\n            break;\n    }\n}\n\nexport { $$component, $$context, $$decline, $$refresh, $$registry };\n",
      "start": 1686078492015,
      "end": 1686078492015
    },
    {
      "name": "vite:import-analysis",
      "result": "import { $DEVCOMP, createMemo, untrack, createSignal, DEV } from '/node_modules/.vite/deps/solid-js.js?v=0b6b363b';\n\nfunction setComponentProperty(component, key, value) {\n    const descriptor = Object.getOwnPropertyDescriptor(component, key);\n    if (descriptor) {\n        Object.defineProperty(component, key, Object.assign(Object.assign({}, descriptor), { value }));\n    }\n    else {\n        Object.defineProperty(component, key, {\n            value,\n            writable: false,\n            enumerable: false,\n            configurable: true\n        });\n    }\n}\nfunction createProxy(source, name, location) {\n    const refreshName = `[solid-refresh]${name}`;\n    function HMRComp(props) {\n        const s = source();\n        if (!s || $DEVCOMP in s) {\n            return createMemo(() => {\n                const c = source();\n                if (c) {\n                    return untrack(() => c(props));\n                }\n                return undefined;\n            }, {\n                name: refreshName\n            });\n        }\n        // no $DEVCOMP means it did not go through devComponent so source() is a regular function, not a component\n        return s(props);\n    }\n    setComponentProperty(HMRComp, 'name', refreshName);\n    if (location) {\n        setComponentProperty(HMRComp, 'location', location);\n    }\n    return new Proxy(HMRComp, {\n        get(_, property) {\n            return source()[property];\n        },\n        set(_, property, value) {\n            source()[property] = value;\n            return true;\n        }\n    });\n}\n\nfunction isListUpdated(a, b) {\n    if (a == null && b != null) {\n        return true;\n    }\n    if (a != null && b == null) {\n        return true;\n    }\n    if (a && b) {\n        const aKeys = Object.keys(a);\n        const bKeys = Object.keys(b);\n        // Check if both objects has the same amount of keys\n        if (aKeys.length !== bKeys.length) {\n            return true;\n        }\n        // Merge keys\n        const keys = new Set([...aKeys, ...bKeys]);\n        // Now check if merged keys has the same amount of keys as the other two\n        // for example: { a, b } and { a, c } produces { a, b, c }\n        if (keys.size !== aKeys.length) {\n            return true;\n        }\n        // Now compare each items\n        for (const key of keys.keys()) {\n            if (!Object.is(a[key], b[key])) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nfunction $$registry() {\n    return {\n        components: new Map(),\n        contexts: new Map()\n    };\n}\nfunction $$component(registry, id, component, options = {}) {\n    const [comp, setComp] = createSignal(component, { internal: true });\n    const proxy = createProxy(comp, id, options.location);\n    registry.components.set(id, Object.assign({ id,\n        component,\n        proxy, update: setComp }, options));\n    return proxy;\n}\nfunction $$context(registry, id, context) {\n    registry.contexts.set(id, {\n        id,\n        context\n    });\n    return context;\n}\nfunction patchComponent(oldData, newData) {\n    // Check if incoming module has signature\n    if (newData.signature) {\n        // Compare signatures\n        if (newData.signature !== oldData.signature ||\n            isListUpdated(newData.dependencies, oldData.dependencies)) {\n            // Replace signatures and dependencies\n            oldData.dependencies = newData.dependencies;\n            oldData.signature = newData.signature;\n            // Remount\n            oldData.update(() => newData.component);\n        }\n    }\n    else {\n        // No granular update, remount\n        oldData.update(() => newData.component);\n    }\n    // Always rely on the first proxy\n    // This is to allow modules newly importing\n    // the updated version to still be able\n    // to render the latest version despite\n    // not receiving the first proxy\n    newData.update(() => oldData.proxy);\n}\nfunction patchComponents(oldData, newData) {\n    const components = new Set([...oldData.components.keys(), ...newData.components.keys()]);\n    for (const key of components) {\n        const oldComponent = oldData.components.get(key);\n        const newComponent = newData.components.get(key);\n        if (oldComponent) {\n            if (newComponent) {\n                patchComponent(oldComponent, newComponent);\n            }\n            else {\n                // We need to invalidate\n                return true;\n            }\n        }\n        else if (newComponent) {\n            oldData.components.set(key, newComponent);\n        }\n    }\n    return false;\n}\nfunction patchContext(oldData, newData) {\n    oldData.context.defaultValue = newData.context.defaultValue;\n    newData.context.id = oldData.context.id;\n    newData.context.Provider = oldData.context.Provider;\n}\nfunction patchContexts(oldData, newData) {\n    const contexts = new Set([...oldData.contexts.keys(), ...newData.contexts.keys()]);\n    for (const key of contexts.keys()) {\n        const oldContext = oldData.contexts.get(key);\n        const newContext = newData.contexts.get(key);\n        if (oldContext) {\n            if (newContext) {\n                patchContext(oldContext, newContext);\n            }\n            else {\n                // We need to invalidate\n                return true;\n            }\n        }\n        else if (newContext) {\n            oldData.contexts.set(key, newContext);\n        }\n    }\n    return false;\n}\nfunction patchRegistry(oldRegistry, newRegistry) {\n    const shouldInvalidateByContext = patchContexts(oldRegistry, newRegistry);\n    const shouldInvalidateByComponents = patchComponents(oldRegistry, newRegistry);\n    // In the future we may add other HMR features here\n    return shouldInvalidateByComponents || shouldInvalidateByContext;\n}\nconst SOLID_REFRESH = 'solid-refresh';\nconst SOLID_REFRESH_PREV = 'solid-refresh-prev';\nfunction $$decline(...[type, hot, inline]) {\n    switch (type) {\n        case 'esm':\n            // Snowpack's ESM assumes invalidate as a normal page reload\n            // decline should be better\n            if (inline) {\n                hot.invalidate();\n            }\n            else {\n                hot.decline();\n            }\n            break;\n        case 'vite':\n            // Vite is no-op on decline, just call invalidate\n            if (inline) {\n                hot.invalidate();\n            }\n            else {\n                hot.accept(() => {\n                    hot.invalidate();\n                });\n            }\n            break;\n        case 'rspack-esm':\n        case 'webpack5':\n            if (inline) {\n                hot.invalidate();\n            }\n            else {\n                hot.decline();\n            }\n            break;\n        case 'standard':\n            // Some implementations do not have decline/invalidate\n            if (inline) {\n                if (hot.invalidate) {\n                    hot.invalidate();\n                }\n                else {\n                    window.location.reload();\n                }\n            }\n            else if (hot.decline) {\n                hot.decline();\n            }\n            else {\n                hot.accept(() => {\n                    if (hot.invalidate) {\n                        hot.invalidate();\n                    }\n                    else {\n                        window.location.reload();\n                    }\n                });\n            }\n            break;\n    }\n}\nlet warned = false;\nfunction shouldWarnAndDecline() {\n    const result = DEV && Object.keys(DEV).length;\n    if (result) {\n        return false;\n    }\n    if (!warned) {\n        console.warn(\"To use solid-refresh, you need to use the dev build of SolidJS. Make sure your build system supports package.json conditional exports and has the 'development' condition turned on.\");\n        warned = true;\n    }\n    return true;\n}\nfunction $$refreshESM(type, hot, registry) {\n    if (shouldWarnAndDecline()) {\n        $$decline(type, hot);\n    }\n    else if (hot.data) {\n        hot.data[SOLID_REFRESH] = hot.data[SOLID_REFRESH] || registry;\n        hot.data[SOLID_REFRESH_PREV] = registry;\n        hot.accept(mod => {\n            if (mod == null || patchRegistry(hot.data[SOLID_REFRESH], hot.data[SOLID_REFRESH_PREV])) {\n                hot.invalidate();\n            }\n        });\n    }\n    else {\n        // I guess just decline if hot.data doesn't exist\n        $$decline(type, hot);\n    }\n}\nfunction $$refreshStandard(type, hot, registry) {\n    if (shouldWarnAndDecline()) {\n        $$decline(type, hot);\n    }\n    else {\n        const current = hot.data;\n        if (current && current[SOLID_REFRESH]) {\n            if (patchRegistry(current[SOLID_REFRESH], registry)) {\n                $$decline(type, hot, true);\n            }\n        }\n        hot.dispose((data) => {\n            data[SOLID_REFRESH] = current ? current[SOLID_REFRESH] : registry;\n        });\n        hot.accept();\n    }\n}\nfunction $$refresh(...[type, hot, registry]) {\n    switch (type) {\n        case 'esm':\n        case 'vite':\n            $$refreshESM(type, hot, registry);\n            break;\n        case 'standard':\n        case 'webpack5':\n        case 'rspack-esm':\n            $$refreshStandard(type, hot, registry);\n            break;\n    }\n}\n\nexport { $$component, $$context, $$decline, $$refresh, $$registry };\n",
      "start": 1686078492016,
      "end": 1686078492018,
      "order": "normal"
    }
  ]
}
